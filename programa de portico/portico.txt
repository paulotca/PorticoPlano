%ALGORÍTIMO PARA ANÁLISE DE PÓRTICO PLANO - PROCESSO DOS DESLOCAMENTOS *
% Aplicativo com implementação do Processo dos Deslocamentos para a
% resolução de Pórticos Planos.
% Universidade Federal de Alagoas - UFAL
% Centro de Tecnologia - CTEC
% Programa de Pós-Graduação em Engenharia Civil - PPGEC
% -------------------------------------------------------------------------
% ALUNO: Roésio Oliveira Santos.
% Disciplina: Mecânica Computacional de Estruturas
% Professor: João Carlos Cordeiro Barbirato(jccb@lccv.ufal.br)

%Entradas de dados:
% Quantidades de nós e elementos:
% Nnos=input('Número de nós: ');
% Nelem=input('Número de elementos: ');
% bla bla balb albalablbal
% %Coordenadas dos nós
% for i=1:Nnos
%     disp('Nó');
%     disp(i);
%     Cx(i)=input('Coordenada x: ');
%     Cy(i)=input('Coordenada y: ');
% end

% %Condições de contorno:
% disp(' Condições de contorno ');
% disp('Para a vinculação dos nós, utilize a seguinte simbologia:');
% disp('Código: 1 para deslocamentos prescritos e 0 para deslocamentos desconhecidos.');
% for i=1:Nnos
%     disp('Para o Nó');
%     disp(i);
%     Cod(3*i-2)=input('Direção x - Vinculação: ');
%     Cod(3*i-1)=input('Direção y - Vinculação: ');
%     Cod(3*i)=input('rotação - Vinculação: ');
%     disp('Ações aplicadas:');
%     Fn(3*i-2)=input('Direção horizontal: ');
%     Fn(3*i-1)=input('Direção vertical: ');
%     Fn(3*i)=input('Momento: ');
% end

 %Conectividade dos elementos:
% for i=1:Nelem
%     disp(' Conectividade dos elementos ');
%     disp('Para o elemento');
%     disp(i);
%     conect(i,1)=input('Nó j: ');
%     conect(i,2)=input('Nó k: ');
%     prop(i,1)=input('Rigidez axial: (EA) ');
%     prop(i,2)=input('Rigidez à flexão: (EI) ');
%     qforcas(i,1)=input('qx: ');
%     qforcas(i,2)=input('qy:  ');
% end

%entrada de dados (Exemplo):
Nnos = 5;
Nelem = 4;
 
%coordenadas
Cx = [0.0 0.0 2.0 3.0 3.0];
Cy = [0.0 1.0 1.0 2.0 0.0];
Cod = [1 1 1 0 0 0 1 1 0 0 0 0 0 1 0];
Fn = [0 0 0 0 0 0 0 0 0 3 -2 1 0 0 0];
conect = [1 2; 2 3; 3 4; 4 5]; 
prop = [10^6 1; 10^6 1; 10^6 1; 10^6 1];
qforcas = [0 0; 0 -10; 0 0; -5 0];

% MONTAGEM DA MATRIZ DE RIGIDEZ GLOBAL

R=zeros(3*Nnos);

for i=1:Nelem
    %Captura de informações dos nós do elemento:
    %conectividade do elemento.
    j=conect(i,1);
    k=conect(i,2);
    %propriedades do elemento.
    ea=prop(i,1);
    ei=prop(i,2);
    %Comprimento do elemento:
    xj=Cx(j);
    xk=Cx(k);
    yj=Cy(j);
    yk=Cy(k);
    L=sqrt((xk-xj)^2+(yk-yj)^2);
    %Matriz de rigidez do elemento(i)tomada na coordenada local é:   
    rei(:,:)=[ea/L    0           0       ea/L    0           0
              0   12*ei/L^3   -6*ei/L^2   0   12*ei/L^3   6*ei/L^2
              0   -6*ei/L^2      4*ei/L   0   -6*ei/L^2    -2*ei/L
              ea/L    0           0       ea/L    0           0
              0   12*ei/L^3   -6*ei/L^2   0   12*ei/L^3   6*ei/L^2
              0   6*ei/L^2      -2*ei/L   0    6*ei/L^2     4*ei/L];
    
    % Sendo a Matriz de incidência cinemática do elemento (i) dada por:
    cs=(xk-xj)/L;
    sn=(yk-yj)/L;
    
    betai(:,:)=[-cs -sn   0   0   0   0
                -sn  cs   0   0   0   0
                 0    0  -1   0   0   0
                 0    0   0   cs  sn  0
                 0    0   0   sn -cs  0
                 0    0   0   0   0   1];
             
    % Cálculo da matriz de rigidez do elemento (i) nas coordenadas globais:
    rgi(:,:) = betai(:,:)'*rei(:,:)*betai(:,:);
    
     %Montagem do vetor posição na matriz global
    j1=3*j-2;
    j2=3*j-1;
    j3=3*j;
    k1=3*k-2;
    k2=3*k-1;
    k3=3*k;
    vposi=[j1 j2 j3 k1 k2 k3];
         
       for lin=1:6
        for col=1:6
            R(vposi(lin),vposi(col)) = R(vposi(lin),vposi(col)) + rgi(lin,col);
        end
    end
end      

%MONTAGEM DO VETOR DE AÇÕES GLOBAIS

%Iniciando com o vetor de forças zerado.
for i=1:(3*Nnos)
    Fne(i)=0;
end

% Intensidades nas coordenadas globais, distribuídas ao longo da barra
for elem=1:Nelem
   
    %Conectividade do elemento:
    j=conect(elem,1);
    k=conect(elem,2);
    
    %Comprimento do elemento:
    xj=Cx(j);
    xk=Cx(k);
    yj=Cy(j);
    yk=Cy(k);
    L=sqrt((xk-xj)^2+(yk-yj)^2);
    
    %Cargas
    qx=qforcas(elem,1);
    qy=qforcas(elem,2);
    
    %Matriz de incidência cinemática do elemento (i):
    cs=(xk-xj)/L;
    sn=(yk-yj)/L;
    
    betai(:,:)=[-cs -sn   0   0   0   0
                -sn  cs   0   0   0   0
                 0    0  -1   0   0   0
                 0    0   0   cs  sn  0
                 0    0   0   sn -cs  0
                 0    0   0   0   0   1];
               
    % Chegamos então as Cargas nas coordenadas globais:
    qxe = qx*cs + qy*sn;
    qye = qx*sn - qy*cs;
    
    Pne_ei = [qxe*L/2 qye*L/2 -qye*L^2/12 -qxe*L/2 -qye*L/2 -qye*L^2/12]';
    
    %Cargas nas coordenadas globais
    Pne_gi = betai(:,:)'*Pne_ei;
    
    %Ações no vetor das forças nodais equivalentes
    j1=3*j-2;
    j2=3*j-1;
    j3=3*j;
    k1=3*k-2;
    k2=3*k-1;
    k3=3*k;
    
    vposi=[j1 j2 j3 k1 k2 k3];
    
    for lin=1:6
        Fne(vposi(lin)) = Fne(vposi(lin)) + Pne_gi(lin);
    end
end

%Completando o vetor das ações globais
F=Fn-Fne;

% Por fim, completando o vetor das ações globais:
F=Fn-Fne;

%Cálculo dos deslocamentos globais
%Resolução do sistema de equações lineares
% Para essa resolução, utilizou-se o método do penalti

for i=1:3*Nnos
    if Cod(i)==1
        R(i,i)=R(i,i)*10^6;
%         F(i)=F(i)*10^6;
    end
end

%Cálculo dos deslocamentos globais
D = R\F';

%Cálculo das ações nas extremidades das barras:

for elem=1:Nelem
        %Conectividade do elemento:
        j=conect(elem,1);
        k=conect(elem,2);
       
        % Propriedades:
        ea=prop(elem,1);
        ei=prop(elem,2);

        %Comprimento do elemento:
        xj=Cx(j);
        xk=Cx(k);
        yj=Cy(j);
        yk=Cy(k);
        L=((xk-xj)^2+(yk-yj)^2)^(1/2);

        %Cargas:
        qx=qforcas(elem,1);
        qy=qforcas(elem,2);
        
        %  Matriz de rigidez do elemento (i):   
    rei(:,:)=[ea/L    0           0       ea/L    0           0
              0   12*ei/L^3   -6*ei/L^2   0   12*ei/L^3   6*ei/L^2
              0   -6*ei/L^2      4*ei/L   0   -6*ei/L^2    -2*ei/L
              ea/L    0           0       ea/L    0           0
              0   12*ei/L^3   -6*ei/L^2   0   12*ei/L^3   6*ei/L^2
              0   6*ei/L^2      -2*ei/L   0    6*ei/L^2     4*ei/L];

        % Matriz de incidência cinemática do elemento (i):
        cs=(xk-xj)/L;
        sn=(yk-yj)/L;

        betai(:,:)=[-cs -sn   0   0   0   0
                    -sn  cs   0   0   0   0
                     0    0  -1   0   0   0
                     0    0   0   cs  sn  0
                     0    0   0   sn -cs  0
                     0    0   0   0   0   1];

                 %Cargas nas coordenadas do elemento
        qxe = qx*cs + qy*sn;
        qye = qx*sn - qy*cs;

        Pne_ei = [qxe*L/2 qye*L/2 -qye*L^2/12 -qxe*L/2 -qye*L/2 -qye*L^2/12]';

        %Ações no vetor das forças nodais equivalentes
        j1=3*j-2;
        j2=3*j-1;
        j3=3*j;
        k1=3*k-2;
        k2=3*k-1;
        k3=3*k;

        vposi=[j1 j2 j3 k1 k2 k3];
        % A Incidência dos deslocamentos globais nos locais será dada por:
        for i=1:6
            Dg(i)=D(vposi(i));
        end
        
        %Transformação para as coordenadas locais
        De=betai*Dg';
        
        %Esforços solicitantes no elemento
        P_ei = Pne_ei + rei*De;
        
        El(elem).De = De;
        El(elem).P_ei = P_ei;
end
    
 %CÁLCULO DAS REAÇÕES DE APOIO:
 
 RA=zeros(3*Nnos,1);
    
    for elem=1:Nelem
        %Conectividade do elemento:
        j=conect(elem,1);
        k=conect(elem,2);
        
        % Propriedades do elemento:
        ea=prop(elem,1);
        ei=prop(elem,2);

        %Comprimento do elemento:
        xj=Cx(j);
        xk=Cx(k);
        yj=Cy(j);
        yk=Cy(k);
        L=((xk-xj)^2+(yk-yj)^2)^(1/2);

        %Cargas:
        qx=qforcas(elem,1);
        qy=qforcas(elem,2);
        
        
    %Matriz de rigidez do elemento (i):   
    rei(:,:)=[ea/L    0           0       ea/L    0           0
              0   12*ei/L^3   -6*ei/L^2   0   12*ei/L^3   6*ei/L^2
              0   -6*ei/L^2      4*ei/L   0   -6*ei/L^2    -2*ei/L
              ea/L    0           0       ea/L    0           0
              0   12*ei/L^3   -6*ei/L^2   0   12*ei/L^3   6*ei/L^2
              0   6*ei/L^2      -2*ei/L   0    6*ei/L^2     4*ei/L];

        %Matriz de incidência cinemática do elemento (i):
        cs=(xk-xj)/L;
        sn=(yk-yj)/L;

        betai(:,:)=[-cs -sn   0   0   0   0
                    -sn  cs   0   0   0   0
                     0    0  -1   0   0   0
                     0    0   0   cs  sn  0
                     0    0   0   sn -cs  0
                     0    0   0   0   0   1];

        %Cargas nas coordenadas do elemento:
        qxe = qx*cs + qy*sn;
        qye = qx*sn - qy*cs;

        Pne_ei = [qxe*L/2 qye*L/2 -qye*L^2/12 -qxe*L/2 -qye*L/2 -qye*L^2/12]';

        %Ações no vetor das forças nodais equivalentes:
        j1=3*j-2;
        j2=3*j-1;
        j3=3*j;
        k1=3*k-2;
        k2=3*k-1;
        k3=3*k;

        vposi=[j1 j2 j3 k1 k2 k3];
        
        for i=1:6
           Pne_ei(i,1) = El(elem).P_ei(i);
        end
        
        %Cargas nas coordenadas globais:
        Pne_gi = betai*Pne_ei;

        %Reações nos apoios:
        for lin=1:6
            if Cod(vposi(lin))==1
                RA(vposi(lin)) = RA(vposi(lin)) + Pne_gi(lin);
            end
        end
    end
for i=1:3*Nnos
    if Cod(i)==1 && Fn(i)~=0
        RA(i) = RA(i)-Fn(i);
    end
end

% Os resultados serão mostrados em um arquivo no formato txt.

% SAÍDA DE DADOS:

%ARQUIVO DE SAÍDA DE DADOS
fp=fopen('resultado_portico.txt','wt');

fprintf(fp,'\n---                 UFAL/CTEC/PPGEC                ---');
fprintf(fp,'\n--- ANÁLISE DE PORTICO PLANO - SAÍDA DE DADOS   ---');
fprintf(fp,'\n---     MECÂNICA COMPUTACIONAL DE ESTRUTURAS    ---');
fprintf(fp,'\n---------------------------------------------------');
fprintf(fp,'\n---        Roésio Oliveira Santos      ---');


%Dados de Entrada
fprintf(fp,'*Dados de Entrada do problema:\n');
% informações dos Nós
fprintf(fp,'\nInformações dos Nós:\n');
fprintf(fp,'Número de nós: %d\n',Nnos);
for i=1:Nnos
    fprintf(fp,'Nó: %d\t(x,y)=(%f,%f)\tPresc: (%d,%d,%d)\tForça Ap: (%f,%f,%f)\n',i,Cx(i),Cy(i),Cod(3*i-2),Cod(3*i-1),Cod(3*i),Fn(3*i-2),Fn(3*i-1),Fn(3*i));        
end

%Elementos

fprintf(fp,'\nInformações dos Elementos:\n');
fprintf(fp,'Números de elemos: %d\n',Nelem);
for i=1:Nelem
    fprintf(fp,'Elem: %d\tNóJ: %d\tNóK: %d\tEA: %f\tEI: %f\tqx: %f\tqy: %f\n',i,conect(i,1),conect(i,2),prop(i,1),prop(i,2),qforcas(i,1),qforcas(i,2));
end

%Dados de Saída  
fprintf(fp,'\n*Resultados obtidos:\n');
%Deslocamentos
fprintf(fp,'\nDeslocamentos de cada coordenada local dos elementos:\n');
for i=1:Nelem
    for j=1:6
        fprintf(fp,'%d\t%.3e\n',i,El(i).De(j));
    end
end

%Esforções internos solicitantes
fprintf(fp,'\nEsforços Internos Solicitantes:\n');
for i=1:Nelem
    for j=1:6
        fprintf(fp,'%d\t%.3e\n',i,El(i).P_ei(j));
    end
end

%Reações de apoio
fprintf(fp,'\nReações de Apoio:\n');
for i=1:Nnos
    for j=1:3
        fprintf(fp,'%d\t%.3e\n',i,RA(3*i+j-3));
    end
end

fclose(fp);
        
        
        
        
        
        
        
        
        
        
        
        

